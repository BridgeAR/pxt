\section{Related Work}
\label{sec:related}

Related work breaks into two parts, following the
flow of the paper: the programming of MCUs,
and embedded runtime environments for MCUs.

\subsection{Programming microcontrollers}

There are four ways to program MCUs,
(ordered roughly from lower to greater resource usage):
\begin{itemize}
\item[1.] a program executing on a host computer sends commands (via some communication protocol)
to a fixed program loaded onto the MCU (e.g., Scratch's
device extensions~\cite{ScratchCACM2009}, Arduino's Firmata library~\cite{Firmata}).
\item[2.] a binary for the MCU is compiled on a host computer and loaded onto the MCU -
this is the common method for Arduino~\cite{buildingArduino2014};
\item[3.] bytecode is compiled on the host and loaded onto MCU, where it is interpreted
(e.g., Java for embedded systems~\cite{ClausenTOPLAS};
\item[4.] a complete compiler and virtual machine are put on the MCU,
as with MicroPython~\cite{MicroPython} and Espruino~\cite{espruinoBook};
% 5. an embedded operating system
\end{itemize}

In the educational and maker~\cite{dougherty2012maker} settings, MCUs often are embedded in projects. Here, option 1 has limited utility, as in such projects the MCU is powered by battery and is not connected to a host. Option 2 does not operate well on computers where installation of programs and additional software is forbidden, common in educational environments. Options 3 and 4 suffer in terms of performance on small MCUs, operating slower than native C++ code, and consuming most of the resources (flash and RAM) of the MCU.

Our platform slots into options 2 and 3, using the \MC architecture and USB pen drives to avoid
the need for installation of native applications or device drivers. Our use of STS provides
better performance than the MicroPython and Espruino solution, as demonstrated in the evaluation,
and allows us to fit in the very constrained space of the Uno. 

\subsection{Embedded Runtime Environments}

Typically written in C and/or C++, environments for MCU programming all share a common design goal: to support developers by providing primitives and programming abstractions. Platforms can range from simple C++ classes that control hardware, to real-time operating systems (RTOSs) with scheduling and memory management.

Arduino~\cite{buildingArduino2014} is an example of a simple platform where the developer uses
high-level APIs to control hardware; there is no scheduler, and memory management
is discouraged through a heavy emphasis on global variables.

TinyOS~\cite{levis2005tinyos}, Contiki~\cite{dunkels2012contiki}, RIOT OS~\cite{baccelli2013riot}, Mynewt~\cite{ApacheMy53:online} mbed OS~\cite{ARMmbed}, Zephyr~\cite{HomeZeph63:online} are RTOS solutions known widely in the systems community. The majority focus on the networking features of sensor based devices and commonly adopt a preemptive scheduling model, which leads to competition over resources resolved using locks and condition synchronization primitives. Contiki has a cooperative scheduler, but uses proto-threads to store thread context --- local variables are not allowed as the context of the stack is not stored.

Although the platforms above are widely used by C/C++ developers, none of these existing solutions align well with the programming paradigms seen in higher level languages.
\CO bridges that semantic gap between the higher level language and the microcontroller, offering appropriate abstractions and higher level primitives written natively in C++.

