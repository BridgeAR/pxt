\section{Related Work}
\label{sec:related}

Related work breaks into three parts, following the
flow of the paper: the programming of MCUs,
type systems for JavaScript, and embedded runtime environments
for MCUs.

\subsection{Programming microcontrollers}

There are four ways to program MCUs,
(ordered roughly from lower to greater resource usage):
\begin{itemize}
\item[1.] a program executing on a host computer sends commands (via some communication protocol)
to a fixed program loaded onto the MCU (e.g., Scratch's
device extensions~\cite{ScratchCACM2009}, Arduino's Firmata library~\cite{Firmata}).
\item[2.] a binary for the MCU is compiled on a host computer and loaded onto the MCU -
this is the common method for Arduino~\cite{buildingArduino2014};
\item[3.] bytecode is compiled on the host and loaded onto MCU, where it is interpreted
(e.g., Java for embedded systems~\cite{ClausenTOPLAS};
\item[4.] a complete compiler and virtual machine are put on the MCU,
as with MicroPython~\cite{MicroPython} and Espruino~\cite{espruinoBook};
% 5. an embedded operating system
\end{itemize}

In the educational and maker~\cite{dougherty2012maker} settings, MCUs often are embedded in projects. Here, option 1 has limited utility, as in such projects the MCU is powered by battery and is not connected to a host. Option 2 does not operate well on computers where installation of programs and additional software is forbidden, common in educational environments. Options 3 and 4 suffer in terms of performance on small MCUs, operating slower than native C++ code, and consuming most of the resources (flash and RAM) of the MCU.

Our platform slots into options 2 and 3, using the \MC architecture and USB pen drives to avoid
the need for installation of native applications or device drivers. Our use of STS provides
better performance than the MicroPython and Espruino solution, as demonstrated in the evaluation,
and allows us to fit in the very constrained space of the Uno. 

% https://github.com/jerryscript-project

% JerryScript is a lightweight JavaScript engine for resource-constrained devices
% uch as microcontrollers. It can run on devices with less than 64 KB of RAM and
% less than 200 KB of flash memory.

% Key characteristics of JerryScript:

% Full ECMAScript 5.1 standard compliance
% 160K binary size when compiled for ARM Thumb-2



% https://github.com/cesanta/mongoose-os
% - Supported microcontrollers: CC3220, CC3200, ESP32, ESP8266, STM32F4;
% https://github.com/cesanta/mjs

% On 32-bit ARM mJS engine takes about 25k of flash memory,
% and less than 1k of RAM (see intro article). mJS is part of MongooseOS,
% where it enables scripting for IoT devices.

% Restrictions
% No closures, only lexical scoping (i.e. nested functions are allowed).
% No new. In order to create an object with a custom prototype, use Object.create(), which is available.
% No getters, setters, classes, template strings.

\subsection{Types for JavaScript}

By design, TypeScript does not provide a type soundness guarantee~\cite{BiermanAT14}.

Safe TypeScript~\cite{SafeTypeScript15} separates the worlds of typed and untyped
objects: the \emph{dynamic} type is an implicit union type of all \emph{known} static type,
while Any is an \emph{unknown} type, coming from the untyped JavaScript world. Type tags
are needed to distinguish the two worlds; Safe TypeScript also adds extra runtime checks
to prevent untyped JavaScript from destroying the type invariants of typed JavaScript.

StrongScript~\cite{StrongScriptECOOP15} extends TypeScript with a type constructor (!)
for \emph{concrete} types, which allows the programmer to choose between untyped
code, optionally-typed code, and concretely typed code, which provides traditional
type soundness guarantees. As with TypeScript, every JavaScript program is a StrongScript program.

STS differs from these efforts by outlawing untyped or optionally typed
code: it is a non-goal of STS to support arbitrary JavaScript programs.
In this sense, STS can be seen to be StrongScript where every variable and
expression has a concrete (!) type. As in StrongScript, classes are nominally typed,
which permits a more efficient and traditional property lookup for class instances.
STS goes further by outlawing downcasts (necessary for our untagged
implementation).

STS could benefit by enlarging the set of types
that can be inferred, so that more JavaScript idioms could be allowed.
Chandra's work on type inference for static compilation of
JavaScript~\cite{ChandraOOPSLA2016} is one path forward.

\subsection{Embedded Runtime Environments}

Typically written in C and/or C++, environments for MCU programming all share a common design goal: to support developers by providing primitives and programming abstractions. Platforms can range from simple C++ classes that control hardware, to real-time operating systems (RTOSs) with scheduling and memory management.

Arduino~\cite{buildingArduino2014} is an example of a simple platform where the developer uses
high-level APIs to control hardware; there is no scheduler, and memory management
is discouraged through a heavy emphasis on global variables.

TinyOS~\cite{levis2005tinyos}, Contiki~\cite{dunkels2012contiki}, RIOT OS~\cite{baccelli2013riot}, Mynewt~\cite{ApacheMy53:online} mbed OS~\cite{ARMmbed}, Zephyr~\cite{HomeZeph63:online} are RTOS solutions known widely in the systems community. The majority focus on the networking features of sensor based devices and commonly adopt a preemptive scheduling model, which leads to competition over resources resolved using locks and condition synchronization primitives. Contiki has a cooperative scheduler, but uses proto-threads to store thread context --- local variables are not allowed as the context of the stack is not stored.

Although the platforms above are widely used by C/C++ developers, none of these existing solutions align well with the programming paradigms seen in higher level languages.
\CO bridges that semantic gap between the higher level language and the microcontroller, offering appropriate abstractions and higher level primitives written natively in C++.

